from .constants import *
from .utils import *
from .models import *
from .serializers import *

import time
from django.shortcuts import render, HttpResponse, HttpResponseRedirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib.auth import authenticate, login, logout
from django.views.decorators.csrf import csrf_exempt
from django.utils import timezone
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django.utils.encoding import smart_str
from rest_framework.response import Response
from rest_framework import status
from rest_framework.views import APIView
from rest_framework.authentication import SessionAuthentication, BasicAuthentication
from rest_framework import serializers

import random
import editdistance
from datetime import timedelta, date
from datetime import datetime as newdate
import calendar
from django.core.mail import EmailMultiAlternatives
import csv
import pandas as pd
import numpy as np
from itertools import chain
import smtplib
import math
from time import gmtime, strftime
import logging
import requests
from random import randint

logger = logging.getLogger('my_logger')
# Create your views here.
def config_logger():
    log_file_name = 'EasyChatLog.log'
    logging_level = logging.WARNING
    formatter = logging.Formatter('%(asctime)s %(name)s %(levelname)s %(message)s')
    handler = logging.handlers.TimedRotatingFileHandler(log_file_name, when='midnight', backupCount=2000)
    handler.setFormatter(formatter)
    logger = logging.getLogger('my_logger')
    logger.addHandler(handler)
    logger.setLevel(logging_level)
    logger.propagate = False

class CsrfExemptSessionAuthentication(SessionAuthentication):
    def enforce_csrf(self, request):
        return  # To not perform the csrf check previously happening


def do_pre_processing(message):
    try:
        message = message.lower()
        message = remove_nonalphanumeric(message)
        message = autocorrect(message)
        message = preprocess_question(message)

        return message
    except Exception as e:
        print("do_pre_processing Error", e)
        return message


def returnNextTree(tree, user_id):
    try:
        TypableData = IsTypableData.objects.filter(entity_name=tree.question_entity_type.entity_group.type,
                                                   user__user_id=user_id)
        if TypableData.count() > 0:
            mapper_count = tree.mapper.all().count()
            if mapper_count == 1:
                mappers = tree.mapper.all()[0]
                return returnNextTree(mappers.tree, user_id)
            else:
                mappers = tree.mapper.all()
                for mapper in mappers:
                    for data in TypableData:
                        choice = data.entity_value
                        if (choice == mapper.choices.choice_name):
                            if tree.question_entity_type.entity_group.is_primary:
                                print("GGGGGGGGGGGGGGGGGGGGGGGGGGGOOOOOOOOOOOOOOOOOOOOOOOOOEEEEEEEEEEEEEEEEEEEEEEEEEESSSSSSSSSSSSSSSSSSSS")
                                user = Profile.objects.get(user_id=user_id)
                                user.current_entity = mapper.choices
                                user.save()
                            return returnNextTree(mapper.tree, user_id)
            return tree
        else:
            return tree
    except Exception as e:
        print("returnNextTree Error", e)
        return tree


def find_last_tree_from_persistent_entities(tree, user_id):
    try:
        tree = returnNextTree(tree, user_id)
        print("TREE GOT IS", tree)
        return (tree)
    except Exception as e:
        print("find_last_tree_from_persistent_entities Error", e)
        return (tree)


def create_data_stages(tree, user_id, channel):
    print("TREE FOR DATA IS", tree)
    try:
        json = {}
        if tree.question_entity_type is not None:
            if tree.question_entity_type.entity_group.is_typable:
                json["is_typable"] = "true"
                json["is_clickable"] = "false"
            if tree.question_entity_type.entity_group.is_clickable:
                json["is_clickable"] = "true"
                json["is_typable"] = "false"
            try:
                json["response"] = parse_sentence2(tree.question_entity_type.question_asked.answer, user_id)
            except Exception as e:
                print("create_data_stages question asked Error", e)
            json["choices"] = create_choice_list(tree.question_entity_type.entity_group)
            json["is_answer"] = "false"
        else:
            json["is_typable"] = "true"
            current_choices = tree.answer.answer_sentence.all()
            if current_choices is not None:
                for choice in current_choices:
                    if choice.channel == channel:
                        answer = choice.answer
                        file = "999abc999"
                        if choice.file is not None:
                            file = choice.file
            print(answer, file)
            try:
                json["response"] = parse_sentence(answer, file, user_id)
            except:
                json["response"] = "The bot is under maintenance."

            print("JSON IS ", json)
            user = Profile.objects.get(user_id=user_id)
            AnalyticsCount(intent=user.current_intent,
                           primary_entity=user.current_entity).save()
            print("JSON IS ", json)
            json["upvote_link"] = "/queryfeedback/" + user.current_query + "/" + user.user_id + "/like/"
            json["downvote_link"] = "/queryfeedback/" + user.current_query + "/" + user.user_id + "/dislike/"
            json["is_answer"] = "true"
            json["recommended_queries"] = recommendations(user.current_intent, user.current_entity)
            objects = IsTypableData.objects.filter(user=user)
            for obj in objects:
                entity_name = obj.entity_name
                entity_obj = EntityType.objects.get(type=entity_name)
                if not entity_obj.is_persistent:
                    try:
                        IsTypableData.objects.filter(user=user,
                                                     entity_name=entity_name).delete()
                    except:
                        print("Error while deleting in create_data")
            print("JSON IS ", json)
            user.tree = None
            user.entities.clear()
            user.current_intent = None
            user.current_entity = None
            user.re_question = False
            user.stage = "pre"
            user.save()
        return json
    except:
        print("Error from create_data")


def saveValueFromMessage(message, tree, user_id):
    try:
        entity_type = tree.question_entity_type.entity_group
        value_extracter = ValueExtracter.objects.filter(
            entitytype__type=entity_type.type).get()
        d = {}
        exec (str(value_extracter.valueextracter), d)
        user_t = Profile.objects.get(user_id=user_id)
        if d['f'](message) is not None:
            print("Value Is: ", d['f'](message))
            IsTypableData(entity_name=entity_type.type,
                          entity_value=d['f'](message),
                          user=user_t).save()
            user = Profile.objects.get(user_id=user_id)
            user.re_question = False
            user.save()
            return True
        else:
            user = Profile.objects.get(user_id=user_id)
            user.re_question = True
            user.save()
            return False
    except Exception as e:
        print("saveValueFromMessage Error", e)


def saveEntity(tree, entities, user_id):
    try:
        print("GOES INSIDE SAVEENTITY")
        if tree.question_entity_type.entity_group.is_clickable:
            if entities is not None:
                entity_type = tree.question_entity_type.entity_group
                print("Inside SaveEntity")
                for entity in entities:
                    choice_value = entity.choice_name
                    print(entity_type.type, choice_value)
                    val_to_save = entity_type.type
                    IsTypableData(entity_name=val_to_save,
                                  entity_value=choice_value,
                                  user=Profile.objects.get(user_id=user_id)).save()
    except Exception as e:
        print("Error from saveEntity", e)


def process_any_tree_with_stages_new(tree, entities, user_id, flag, channel, message, what):
    try:
        current_user = Profile.objects.get(user_id=user_id)
        current_stage = current_user.stage
        if current_stage == "pre":
            execute_activity(tree)
            print("Tree is: ", tree)
            tree = find_last_tree_from_persistent_entities(tree, user_id)
            print("Tree is: ", tree)
            user = Profile.objects.get(user_id=user_id)
            user.tree = tree
            user.stage = "post"
            user.save()
            return create_data_stages(tree, user_id, channel)
        else:
            saveEntity(tree, entities, user_id)
            saveValueFromMessage(message, tree, user_id)
            print("Tree is: ", tree)
            tree = find_last_tree_from_persistent_entities(tree, user_id)
            print("Tree is: ", tree)
            user = Profile.objects.get(user_id=user_id)
            user.tree = tree
            user.stage = "pre"
            user.save()
            return process_any_tree_with_stages_new(tree, entities, user_id, flag, channel, message, what)
    except:
        print("ERROR")

def get_random():
    objects = QueryList.objects.all()

    list_e = []
    for object in objects:
        list_e.append(object.query_name)

    if len(list_e) > 3:
        list_random = random.sample(list_e, 3)
    else:
        list_random = random.sample(list_e, len(list_e))

    return (list_random)
def match_choices_final(tree, message, user_id, channel, language, clicked):
    json = {}
    answer_succesful = True
    initial_message = message
    if tree is None:
        message = do_pre_processing(message)
        entities = get_entity(message)
        intent = get_intent(message)
        recur_entity_tree(entities, user_id)
        current_query = increment_querycnt(message, channel)
        if intent is not None:
            intent_obj = get_object_or_404(Intent, name=intent[0].name)
            add_entities_in_user(entities, intent_obj, current_query, user_id)
            json = process_any_tree_with_stages_new(intent_obj.tree, entities, user_id, "false", channel, message,"true")
        else:
            if entities is not None:
                recommendation_list = get_recommendation_list_from_entities(entities)
                (json, value) = get_recommendation_list_json(recommendation_list)
                answer_succesful = value
                if(value == False):
                    json["recommended_queries"] = get_random()
            else:
                answer_succesful = False
                json["is_typable"] = "true"
                message = str(Config.objects.all()[0].question_not_recognized)
                json["response"] = "I am sorry I could not help you. While I improve please contact customer service executive at our toll-free number 1800 425 3800."
                #json["recommended_queries"] = InitialBaseResponses()
    else:
        message = message.lower()
        message = autocorrect(message)
        entities = get_entity(message)
        json = process_any_tree_with_stages_new(tree, entities, user_id, "false", channel, message, "false")
    chatbot_answer = ""
    try:
        chatbot_answer = json["response"]
    except:
        print("No response")

    Query(message_text=initial_message,
          user=Profile.objects.get(user_id=user_id),
          platform=channel,
          answer_succesfull=answer_succesful,
          chatbot_answer=chatbot_answer,
          language=language,
          clicked=clicked).save()
    return json

def Index(request):
    return render(request, 'engine/index.html', {})

def Iframe(request):
    return render(request, 'engine/chatbox.html', {})


def Analytics(request):
    return render(request, 'engine/analytics.html')

def parse_local(current_answer):
    flag = False
    string = ""
    for words in current_answer.split():
        if words != " ":
            if words == "@}":
                flag = False

            elif flag == True:
                variable_name = words
                variable = Variables.objects.filter(variable_name=variable_name).get()
                if variable is not None:
                    if variable.variable_value:
                        value = variable.variable_value
                        string += value + " "
            elif words == "{@":
                flag = True

            else:
                string += words + " "
    return string

def parse_data(current_answer, user_id):
    flag_what = False
    string = ""
    for words in current_answer.split():
        print(words, flag_what)
        if words == "/}":
            flag_what = False

        elif flag_what == True:
            variable_name = words
            print(IsTypableData.objects.all(), "GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGg")
            obj = IsTypableData.objects.filter(entity_name=variable_name,
                                               user__user_id=user_id)
            count = obj.count()
            needed_obj = obj[count - 1]
            value = needed_obj.entity_value
            if value:
                string += value + " "
        elif words == "{/":
            flag_what = True
        else:
            string += words + " "
    return string


def parse_json(current_answer, file):
    print(file, "ASDADAD")
    if (file != "999abc999"):
        try:
            current_answer = current_answer.replace("<p>", "")
            current_answer = current_answer.replace("</p>", "")
            current_answer = current_answer.replace("&nbsp;", " ")
            df = pd.read_csv(file.file)

            string = ""
            flag_start = False
            word = ""
            flag_colon_start = False
            list = []
            list_to_find = []
            flag_start_2 = False
            for words in current_answer.split():
                print("Words are: ", words)
                if words == ")}":
                    flag_start_2 = False
                elif flag_start_2 == True:
                    list_to_find.append(words)
                elif words == "{(":
                    flag_start_2 = True
                elif words == "]}":
                    flag_start = False
                elif flag_start == True:
                    if flag_colon_start == True:
                        list_t = []
                        list_t.append(word)
                        list_t.append(words)
                        list.append(list_t)
                        flag_colon_start = False
                    if words == ":":
                        flag_colon_start = True
                    if flag_colon_start == False:
                        word = words
                elif words == "{[":
                    flag_start = True
                else:
                    string += words + " "

            for stuff in list:
                str1 = str(stuff[0])
                str2 = str(stuff[1])
                df[str1] = df[str1].astype(str)
                df[str1] = df[str1].str.lower()
                df = df.loc[df[str1] == str2]

            dict_temp = {}
            if (len(list_to_find) > 0):
                for stuff in list_to_find:
                    print(stuff, df.iloc[0][stuff], type(df.iloc[0][stuff]))
                    if stuff == "respone_code":
                        if math.isnan(df.iloc[0][stuff]):
                            dict_temp[stuff] = "NaN"
                        else:
                            dict_temp[stuff] = int(df.iloc[0][stuff])
                    else:
                        dict_temp[stuff] = df.iloc[0][stuff]

            return (string, dict_temp)
        except:
            message = str(Config.objects.all()[0].entry_not_present_in_database)
            return (message, {})
    else:
        return (current_answer, {})


def replace_values(sentence, dict_temp):
    string = ""
    for words in sentence.split():
        if words in dict_temp:
            string += str(dict_temp[words]) + " "
        else:
            string += words + " "
    return string


def replace_if_statement(sentence):
    string = ""

    sentence = sentence.replace('<p>', '')
    sentence = sentence.replace('</p>', '')
    string_answer_1 = ""
    string_answer_2 = ""
    condition = ""
    start_flag = False
    start_flag_2 = False
    start_flag_3 = False
    final_flag = False
    for words in sentence.split():
        # print(words)
        if words == "}}}":
            start_flag = False
        if start_flag == True:
            string_answer_1 += words + " "
        if words == "{{{":
            start_flag = True

        if words == "}}}}":
            start_flag_2 = False
        if start_flag_2 == True:
            string_answer_2 += words + " "
        if words == "{{{{":
            start_flag_2 = True

        if words == "))}":
            start_flag_3 = False
            final_flag = True
        if start_flag_3 == True:
            condition += words + " "
        if words == "{((":
            start_flag_3 = True

    condition = condition.replace(" ", "")
    if final_flag == True:
        if condition != "nan":
            return string_answer_1
        else:
            return string_answer_2
    else:
        return sentence


def parse_api(message, user_id):
    try:
        print("URL IS: INSIDE PARSE API", message)
        string = ""
        final_string = ""
        flag_api = False
        for words in message.split():
            if words == "*}":
                flag_api = False
            elif flag_api == True:
                string += words + " "
            elif words == "{*":
                flag_api = True
            else:
                final_string += words + " "

        list = string.split(',')
        dict = {}
        temp_dict = {}
        for val in list:
            key, pair = val.split('[')
            if (key == "url"):
                dict["url"] = pair
            if (key == "type"):
                dict["type"] = pair
            if (key == "data"):
                pair = pair[1:]
                pair = pair[:-1]
                temp_list = pair.split(';')
                for item in temp_list:
                    keey, valuee = item.split("-")
                    temp_dict[keey] = valuee
                temp_dict["user_id"] = user_id
                dict["data"] = temp_dict
            if (key == "output"):
                pair = pair[1:]
                pair = pair[:-1]
                list = pair.split(';')
                dict["output"] = list

        if (dict["type"] == "GET"):
            a = requests.get(dict["url"])
        elif (dict["type"] == "POST"):
            answer = requests.post(dict["url"], dict["data"])

        answer = answer.json()

        for key, value in answer.items():
            print (key, value)
            for words in final_string.split():
                print("Words are: ", words, key)
                if words == key:
                    print("EQUALS:: ", words, str(value))
                    final_string = final_string.replace(words, str(value))

        return final_string
    except:
        print("Error from: parse_api()")
        return message


def parse_sentence(current_answer, file, user_id):
    # Local Variables {@ @}
    # IsTypableVariables {/ /}
    # IsClickableVariables {+ +}
    # Excel/Json {[ ]} for value giving, {( )} for variables needed
    # if statment {(( condition_here ))} {{{ }}} {{{{ }}}}
    # API CALL {* url:url,type:type,data:{xxx-value;xxxy-value;},output{transaction_id;value} *}
    sentence = current_answer
    sentence = parse_local(sentence)
    sentence = parse_data(sentence, user_id)
    (sentence, dict_temp) = parse_json(sentence, file)
    sentence = replace_values(sentence, dict_temp)
    sentence = replace_if_statement(sentence)
    sentence = parse_api(sentence, user_id)
    return sentence


def parse_sentence2(current_answer, user_id):
    sentence = current_answer
    sentence = parse_local(sentence)
    sentence = parse_data(sentence, user_id)
    return sentence


def autocorrect(message):
    words_in_dict = list(GoodWords.objects.all().values_list('word', flat=True))

    final_message = ''
    for index, elem in enumerate(message.split()):
        if elem != "check":
            if len(elem) > 4:
                if elem in words_in_dict:
                    final_message += elem
                    final_message += ' '
                else:
                    list_of_probable_words = []

                    for word in words_in_dict:
                        if (editdistance.eval(word, elem) <= 2):
                            list_of_probable_words.append(word)

                    if len(list_of_probable_words) > 0:
                        final_message += list_of_probable_words[0] + " "
                    else:
                        final_message += elem + " "
            else:
                final_message += elem + " "
            # if index == 0:
            #     prev_word = "null"
            # else:
            #     prev_word = list_message[index-1]
            #
            # possible_words = Bigrams.objects.filter(word1=prev_word,word2__in=list_of_probable_words).order_by('-cnt')
            #
            # try:
            #     obj = possible_words[0]
            #     list_message[index] = obj.word2
            #     final_message += obj.word2
            #     final_message += ' '
            # except Exception as e:
            #     final_message += elem
            #     final_message += ' '
    print(final_message, "Final Message::::::::::::::::::::::::::::")
    return final_message


def remove_stopwords(message):
    STOP_WORDS = set(STOPWORDS)
    list_t = []
    value = str(Config.objects.all()[0].custom_stop_word)
    for val in value.split(","):
        list_t.append(val)
    set_idk_why = set(list_t)
    message = ' '.join([i for i in message.lower().split() if i not in STOP_WORDS])
    message = ' '.join([i for i in message.lower().split() if i not in set_idk_why])
    return message


def recommendations(intent, entity):
    print("Intent is", intent)
    print("Entity is", entity)
    intent_obj = intent
    entity_obj = entity

    if intent is not None and entity is not None:
        query_name_which_should_not_appear = QueryList.objects.filter(entity=entity_obj, intent=intent_obj)
        with_same_intent = QueryList.objects.filter(intent=intent_obj)

        with_same_entity = QueryList.objects.filter(entity=entity_obj)
        with_same_intent = QueryList.objects.filter(intent=intent_obj)

        list_e = []

        for some_entity in with_same_entity:
            for some_query in query_name_which_should_not_appear:
                if some_entity != some_query:
                    list_e.append(some_entity)

        for some_intent in with_same_intent:
            for some_query in query_name_which_should_not_appear:
                if some_intent != some_query:
                    list_e.append(some_intent)

        list_e = list(set(list_e))

        if len(list_e) > 3:
            list_random = random.sample(list_e, 3)
        else:
            list_random = random.sample(list_e, len(list_e))

        list_query_name = []
        for elem in list_random:
            list_query_name.append(elem.query_name)

        return (list_query_name)

    elif entity is not None:
        objects = QueryList.objects.filter(entity=entity_obj)

        list_e = []
        for object in objects:
            list_e.append(object.query_name)

        if len(list_e) > 3:
            list_random = random.sample(list_e, 3)
        else:
            list_random = random.sample(list_e, len(list_e))

        return (list_random)

    elif intent is not None:
        objects = QueryList.objects.filter(intent=intent_obj)

        list_e = []
        for object in objects:
            list_e.append(object.query_name)

        if len(list_e) > 3:
            list_random = random.sample(list_e, 3)
        else:
            list_random = random.sample(list_e, len(list_e))

        return (list_random)
    return []

def extract_value_from_initial_message(message, user_id):
    try:
        functions = ValueExtracter.objects.all()

        for function_t in functions:
            function_string = function_t.valueextracter
            d = {}
            exec (str(function_string), d)

            value = d['f'](message)

            if value is not None:
                entity_type_name = function_t.entitytype.type
                val_to_save = entity_type_name
                IsTypableData(entity_name=val_to_save,
                              entity_value=value,
                              user=Profile.objects.get(user_id=user_id)).save()
    except:
        print("Error from: extract_value_from_initial_message()")


def recur_entities(current_choice, user_id):
    try:
        parent = current_choice.parent
        user = Profile.objects.get(user_id=user_id)
        user.entities.add(parent)
        user.save()
        recur_entities(parent, user_id)
    except:
        print("Error from: recur_entities()")


def recur_entity_tree(entities, user_id):
    try:
        for entity in entities:
            current_entity = Choices.objects.filter(choice_name=entity.choice_name).get()
            recur_entities(current_entity, user_id)
    except:
        print("Error from: recur_entity_tree()")


def increment_querycnt(message, channel):
    try:
        query_cnt = QueryCnt.objects.filter(question_asked=message).get()
        cnt = query_cnt.count
        cnt = cnt + 1
        QueryCnt.objects.filter(question_asked=message).update(count=cnt)
        current_query = query_cnt.pk
        return current_query
    except:
        query = QueryCnt(question_asked=message,
                         count=0,
                         channel=channel,
                         language="eng")
        query.save()
        current_query = QueryCnt.objects.filter(question_asked=message).get().pk
        return current_query


def add_entities_in_user(entities, intent_objects, query_id, user_id):
    print(entities, intent_objects, query_id, user_id)
    user = Profile.objects.get(user_id=user_id)
    user.tree = intent_objects.tree
    if entities is not None:
        for entity in entities:
            for entity_type in entity.entity_choices.all():
                print("Entity Name: ", entity_type.type)
                val_to_save = entity_type.type
                IsTypableData(entity_name=val_to_save,
                              entity_value=entity.choice_name,
                              user=Profile.objects.get(user_id=user_id)).save()
            # user.entities.add(entity)
            # if (entity.is_persistent):
            # user.persistent_entities.add(entity)
    user.current_intent = intent_objects
    user.current_query = query_id
    user.save()

def execute_activity(tree):
    try:
        activity = tree.activity
        if (activity != ""):
            d = {}
            exec (activity, d)
    except:
        print("Error in: execute_activity()")


def get_all_user_entities(user_id):
    user = Profile.objects.get(user_id=user_id)
    print(user.entities.all())
    print(user.persistent_entities.all())
    total_entities = list(chain(user.entities.all(), user.persistent_entities.all()))
    print(total_entities)
    return total_entities


def create_choice_list(entity_type):
    try:
        print("Goes in: error_choice_list()")
        choices = entity_type.choices.all()
        choice_list = []
        for choice in choices:
            choice_list.append(choice.choice_name)
        return choice_list
    except:
        print("Error in: create_choice_list()")


def get_values_dictionary(entity_type, user_id):
    try:
        print(entity_type, user_id)
        objects = IsTypableData.objects.filter(entity_name=entity_type.type,
                                               user__user_id=user_id)
        print (objects.count(), "ASAAAAAAAAAAAAAAAAAAAAAAA")
        obj = objects[objects.count() - 1]
        return (True, obj.entity_value)
    except:
        print("Error in: create_values_dictionary()")
        return (False, "")


def parse_question(message):
    print(message, " Question is:")
    message = message.replace("<p></p>", "")
    message = message.replace("<p> </p>", "")

    return message


def get_recommendation_list_from_entities(entities):
    try:
        recommendation_list = []
        for entity in entities:
            temp_list = recommendations(intent=None, entity=entity)
            recommendation_list.extend(temp_list)
        return recommendation_list
    except:
        print("Error in: get_recommendation_list_from_entities()")


def get_recommendation_list_json(recommendation_list):
    try:
        json = {}
        boolean = True
        if (len(recommendation_list) > 0):
            json["recommended_queries"] = recommendation_list
            message = str(Config.objects.all()[0].recommended_queries_statement)
            json["response"] = message
        else:
            message = str(Config.objects.all()[0].question_not_recognized)
            json["response"] = message
            boolean = False
        json["is_typable"] = "true"
        return (json, boolean)
    except:
        print("Error in: get_recommendation_list_json()")

def remove_nonalphanumeric(message):
    answer = ""
    for words in message.split():
        word = words
        word_no_alpha = ''.join(e for e in word if e.isalnum())
        answer += word_no_alpha + " "
    return answer


class CancelAPIView(APIView):
    authentication_classes = (
        CsrfExemptSessionAuthentication, BasicAuthentication)

    def post(self, request):
        data = request.data
        json = {}
        json["is_typable"] = "true"

        user_id = data.get('user_id', False)

        user = Profile.objects.get(user_id=user_id)
        objects = IsTypableData.objects.filter(user=user)
        for obj in objects:
            entity_name = obj.entity_name
            entity_obj = EntityType.objects.get(type=entity_name)
            if not entity_obj.is_persistent:
                try:
                    IsTypableData.objects.filter(user=user,
                                                 entity_name=entity_name).delete()
                except:
                    print("AA")
        user.tree = None
        user.entities.clear()
        user.current_intent = None
        user.re_question = False
        user.stage = "pre";
        user.save()
        message = str(Config.objects.all()[0].cancel_button_message)
        json["response"] = "Hello, how may I assist you? I can help you with SBI Bank related queries.Please select a quick link below or type your question in the space provided."
        json["recommended_queries"] = InitialBaseResponses()
        return Response(data=json)


class OverallFeedbackAPIView(APIView):
    authentication_classes = (
        CsrfExemptSessionAuthentication, BasicAuthentication)

    def post(self, request):
        data = request.data

        feedback = data.get('feedback')
        user_id = data.get('user_id')

        try:
            fdback = FeedbackGeneral.objects.filter(user_id=user_id).get()
            fdback.feedback = feedback
            fdback.save()
        except:
            fdback = FeedbackGeneral(user_id=user_id,
                                     feedback=feedback)
            fdback.save()

        return Response(data={})


class QueryFeedbackLikeAPIView(APIView):
    authentication_classes = (
        CsrfExemptSessionAuthentication, BasicAuthentication)

    def get(self, request, *args, **kwargs):
        data = self.kwargs
        ##print(data, "DATAAAAAAAAAAAAAAAAAAAAAAA")
        user_id = data["user_id"]
        query_id = data["query_id"]
        try:
            fdback = FeedbackQuery.objects.filter(user__user_id=user_id,
                                                  query__pk=query_id).get()
            like_cnt = fdback.like_cnt
            like_cnt = like_cnt + 1
            fdback.like_cnt = like_cnt
            fdback.save()
        except:
            user = Profile.objects.get(user_id=user_id)
            FeedbackQuery(user=user,
                          query_id=query_id).save()
        return Response(data={})


class QueryFeedbackDislikeAPIView(APIView):
    authentication_classes = (
        CsrfExemptSessionAuthentication, BasicAuthentication)

    def get(self, request, *args, **kwargs):
        data = self.kwargs
        # print(data, "DATAAAAAAAAAAAAAAAAAAAAAAA")
        user_id = data["user_id"]
        query_id = data["query_id"]
        try:
            fdback = FeedbackQuery.objects.filter(user__user_id=user_id,
                                                  query__pk=query_id).get()
            dislike_cnt = fdback.dislike_cnt
            dislike_cnt = dislike_cnt + 1
            fdback.dislike_cnt = dislike_cnt
            fdback.save()
        except:
            FeedbackQuery(user_id=user_id,
                          query_id=query_id).save()
        return Response(data={})


class QueryAPIView(APIView):
    authentication_classes = (
        CsrfExemptSessionAuthentication, BasicAuthentication)

    def post(self, request):
        data = request.data

        message = data.get('message', False)
        user_id = data.get('user_id', False)
        channel = data.get('channel', False)
        language = data.get('language', False)
        clicked = data.get('clicked_or_typed', False)

        message = message.lower()

        user = Profile.objects.get(user_id=user_id)
        current_tree = user.tree

        json = match_choices_final(current_tree, message, user_id, channel, language, clicked)

        return Response(data=json)


class UpdateAnswerAPIView(APIView):
    def post(self, request):
        data = request.data
        dict2 = data.copy()
        dict2.pop("csrfmiddlewaretoken", None)
        Sentences.objects.create(**dict2)
        return Response(data=dict2)

def InitialBaseResponses():
    list_temp = []
    response_1 = Config.objects.all()[0].base_response_1
    if response_1 is not None:
        if response_1:
            list_temp.append(response_1)
    response_2 = Config.objects.all()[0].base_response_2
    if response_2 is not None:
        if response_2:
            list_temp.append(response_2)
    response_3 = Config.objects.all()[0].base_response_3
    if response_3 is not None:
        if response_3:
            list_temp.append(response_3)
    response_4 = Config.objects.all()[0].base_response_4
    if response_4 is not None:
        if response_4:
            list_temp.append(response_4)
    response_5 = Config.objects.all()[0].base_response_5
    if response_5 is not None:
        if response_5:
            list_temp.append(response_5)
    return list_temp
class UpdateUserAPIView(APIView):
    authentication_classes = (
        CsrfExemptSessionAuthentication, BasicAuthentication)

    def post(self, request):
        print("CALLS WTF M8")
        data = request.data
        dict2 = {}
        ##print (data.get('user_id'))
        dict2['user_id'] = data.get('user_id')
        print(dict2['user_id'], "AAAAAAAAA")
        # dict2['user_name'] = data.get('username')
        # dict2 = data.copy()
        # dict2.pop("csrfmiddlewaretoken", None)
        ##print(dict2)
        Profile.objects.create(**dict2)

        json = {}
        json["is_typable"] = "true"
        json["response"] = Config.objects.all()[0].initial_message
        list_temp = InitialBaseResponses()

        json["recommended_queries"] = list_temp
        print(json)
        return Response(data=json)


def createBlankDictionary(value, choice, start_date):
    dict = {}

    # print(value,choice,start_date, "Lol", type(choice))
    if choice == "0":
        current_date = start_date
        for i in range(value + 1):
            # print(current_date, "current date")
            t = current_date.strftime('%d/%m/%Y')
            dict[t] = 0
            current_date += timedelta(days=1)
    elif choice == "1":
        ##print("ASD")
        current_month = start_date.month - 1
        # print(current_month)
        for i in range(value + 1):
            current_month += 1
            if current_month == 13:
                current_month = 1
            dict[calendar.month_name[current_month]] = 0
            # print(calendar.month_name[current_month][:3], current_month)
    else:
        current_year = start_date.year
        # print(current_year)
        for i in range(value + 1):
            dict[current_year] = 0
            current_year += 1

    return dict


def returnChoice(date1, date2):
    delta = date2 - date1
    days = delta.days
    years, remainder = divmod(days, 365)
    months = years * 12 + (remainder // 30)

    # print(days, months, years, remainder)

    if days > 0:
        if (years > 0):
            return (years, "2")
        elif (months > 0):
            return (months, "1")
        else:
            return (days, "0")

    return (days, "-1")


def Report(request, from_date, to_date):
    # print(to_date, from_date)
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="sia_report.csv"'

    writer = csv.writer(response)
    writer.writerow([
        'Message Text',
        'Answered (Yes or No)',
        'user_id',
        'chatbot_answer'
    ])

    from_date = from_date.split("/")
    to_date = to_date.split("/")

    start_date = date(int(from_date[2]), int(from_date[1]), int(from_date[0]))
    end_date = date(int(to_date[2]), int(to_date[1]), int(to_date[0]))

    # print(start_date, end_date, "WWWWW")

    queries = Query.objects.filter(message_time__range=(start_date, end_date))

    for query in queries:
        if query.message_time is not None:
            ans = "No"
            if query.answer_succesfull:
                ans = "Yes"
            writer.writerow([
                smart_str(query.message_text),
                ans,
                smart_str(query.user.user_id),
                smart_str(query.chatbot_answer)
            ])

    return response


class GetPcIdAPIView(APIView):
    authentication_classes = (
        CsrfExemptSessionAuthentication, BasicAuthentication)

    def post(self, request):
        data = request.data

        pc_id = data.get('pcid')

        try:
            PcId.objects.filter(name=pc_id).get()
        except:
            p = PcId(name=pc_id)
            p.save()

        return Response(data={})


class GetAnalysisAPIView(APIView):
    authentication_classes = (
        CsrfExemptSessionAuthentication, BasicAuthentication)

    def post(self, request):
        data = request.data

        from_date = data.get('from_date').split("/")
        to_date = data.get('to_date').split("/")

        start_date = date(int(from_date[2]), int(from_date[1]), int(from_date[0]))
        end_date = date(int(to_date[2]), int(to_date[1]), int(to_date[0]))

        # print("Start Date: ", start_date)
        # print("End Date: ", end_date)

        choices = returnChoice(start_date, end_date)
        # print(choices)

        current_choice = choices[1]
        value = choices[0]

        dict_count = createBlankDictionary(value, current_choice, start_date)
        answered_count = createBlankDictionary(value, current_choice, start_date)
        unanswered_count = createBlankDictionary(value, current_choice, start_date)

        entity_count = {}

        intent_top_entity = {}
        entity_top_intent = {}

        platform_dict = {}

        final_dict = {}

        answered_messages = []
        unanswered_messages = []
        total_message = []

        dict_user_cnt = createBlankDictionary(value, current_choice, start_date)
        dict_message_cnt = createBlankDictionary(value, current_choice, start_date)
        final_average_dict = createBlankDictionary(value, current_choice, start_date)

        total_unique_users = createBlankDictionary(value, current_choice, start_date)

        queries = Query.objects.filter(message_time__range=(start_date, end_date))
        analytics = AnalyticsCount.objects.filter(message_time__range=(start_date, end_date))
        unique_users = PcId.objects.filter(message_time__range=(start_date, end_date))

        print(queries, "Queries")
        # print(analytics, "Analytics")
        # print(unique_users, "Unique users")

        list_insights_1 = {}
        for query in queries:
            print("BBBBBBB")
            if query.message_time is not None:
                print("AAAAAAAAAA")
                total_message.append(query.message_text + " " + query.user.user_id)
                if query.answer_succesfull == True:
                    answered_messages.append(query.message_text + " " + query.user.user_id)
                else:
                    unanswered_messages.append(query.message_text + " " + query.user.user_id)
                current_platform = query.platform
                if current_platform != "False":
                    if current_platform not in platform_dict:
                        platform_dict[current_platform] = 1
                    else:
                        platform_dict[current_platform] += 1

                t = query.message_time
                if current_choice == "0":
                    dict_count[t.strftime('%d/%m/%Y')] += 1
                    if query.answer_succesfull == True:
                        answered_count[t.strftime('%d/%m/%Y')] += 1
                    else:
                        unanswered_count[t.strftime('%d/%m/%Y')] += 1
                elif current_choice == "1":
                    dict_count[calendar.month_name[t.month]] += 1
                    if query.answer_succesfull == True:
                        answered_count[calendar.month_name[t.month]] += 1
                    else:
                        unanswered_count[calendar.month_name[t.month]] += 1
                else:
                    dict_count[t.year] += 1
                    if query.answer_succesfull == True:
                        answered_count[t.year] += 1
                    else:
                        unanswered_count[t.year] += 1
                list_insights_1["total_messages"] = dict_count
                list_insights_1["answered_messages"] = answered_count
                list_insights_1["unanswered_messages"] = unanswered_count

        dict_user = {}
        for query in queries:
            if query.message_time is not None:
                t = query.message_time

                if current_choice == "0":
                    dict_message_cnt[t.strftime('%d/%m/%Y')] += 1
                    if query.user.user_id not in dict_user:
                        dict_user[query.user.user_id] = 1
                        dict_user_cnt[t.strftime('%d/%m/%Y')] += 1
                elif current_choice == "1":
                    dict_message_cnt[calendar.month_name[t.month]] += 1
                    if query.user.user_id not in dict_user:
                        dict_user[query.user.user_id] = 1
                        dict_user_cnt[calendar.month_name[t.month]] += 1
                else:
                    dict_message_cnt[t.year] += 1
                    if query.user.user_id not in dict_user:
                        dict_user[query.user.user_id] = 1
                        dict_user_cnt[t.year] += 1

        # print(dict_user_cnt, dict_message_cnt)
        for key, elem in final_average_dict.items():
            users = dict_user_cnt[key]
            messages = dict_message_cnt[key]

            if users != 0:
                average = messages / users
            else:
                average = 0
            final_average_dict[key] = average

        # print(final_average_dict,"average")

        final_dict["list_insights_1"] = list_insights_1
        final_dict["platform_dict"] = platform_dict
        final_dict["average_session_time"] = final_average_dict

        for analytic_obj in analytics:
            if analytic_obj.message_time is not None:
                if analytic_obj.primary_entity is not None:
                    if analytic_obj.primary_entity.choice_name not in entity_count:
                        entity_count[analytic_obj.primary_entity.choice_name] = 1
                    else:
                        entity_count[analytic_obj.primary_entity.choice_name] += 1

        final_dict["top_products"] = entity_count

        for analytic_obj in analytics:
            if analytic_obj.message_time is not None:
                if analytic_obj.primary_entity is not None:
                    if analytic_obj.primary_entity.choice_name not in entity_top_intent:
                        entity_top_intent[analytic_obj.primary_entity.choice_name] = {}

        for analytic_obj in analytics:
            # print(entity_top_intent,"GGGG")
            if analytic_obj.message_time is not None:
                if analytic_obj.primary_entity is not None:
                    temp_dict = entity_top_intent[analytic_obj.primary_entity.choice_name]
                    if analytic_obj.intent is not None:
                        if analytic_obj.intent.name not in temp_dict:
                            temp_dict[analytic_obj.intent.name] = 1
                        else:
                            temp_dict[analytic_obj.intent.name] += 1
                    entity_top_intent[analytic_obj.primary_entity.choice_name] = temp_dict

        final_dict["top_intent_in_entities"] = entity_top_intent

        for analytic_obj in analytics:
            if analytic_obj.message_time is not None:
                if analytic_obj.intent is not None:
                    if analytic_obj.intent.name not in intent_top_entity:
                        intent_top_entity[analytic_obj.intent.name] = {}

        for analytic_obj in analytics:
            if analytic_obj.message_time is not None:
                if analytic_obj.intent is not None:
                    temp_dict = intent_top_entity[analytic_obj.intent.name]
                    if analytic_obj.primary_entity is not None:
                        if analytic_obj.primary_entity.choice_name not in temp_dict:
                            temp_dict[analytic_obj.primary_entity.choice_name] = 1
                        else:
                            temp_dict[analytic_obj.primary_entity.choice_name] += 1
                    intent_top_entity[analytic_obj.intent.name] = temp_dict

        for user in unique_users:
            t = user.message_time
            if current_choice == "0":
                total_unique_users[t.strftime('%d/%m/%Y')] += 1
            elif current_choice == "1":
                total_unique_users[calendar.month_name[t.month]] += 1
            else:
                total_unique_users[t.year] += 1

        final_dict["top_entities_in_intent"] = intent_top_entity
        final_dict["total_unique_users"] = total_unique_users
        final_dict["answered_messages"] = answered_messages
        final_dict["unanswered_messages"] = unanswered_messages
        final_dict["total_messages"] = total_message
        return Response(data=final_dict)



UpdateAnswer = UpdateAnswerAPIView.as_view()
UpdateUser = UpdateUserAPIView.as_view()
# UpdateChoices = UpdateChoicesAPIView.as_view()
# UpdateEntity = UpdateEntityAPIView.as_view()
# UpdateTree = UpdateTreeAPIView.as_view()
# UpdateIntent = UpdateIntentAPIView.as_view()
# UpdateMapper = UpdateMapperAPIView.as_view()
Querys = QueryAPIView.as_view()
Cancel = CancelAPIView.as_view()
OverallFeedback = OverallFeedbackAPIView.as_view()
QueryFeedbackLike = QueryFeedbackLikeAPIView.as_view()
QueryFeedbackDislike = QueryFeedbackDislikeAPIView.as_view()
GetAnalysis = GetAnalysisAPIView.as_view()
GetPcId = GetPcIdAPIView.as_view()
# Recommendations = RecommendationsAPIView.as_view()
